(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{593:function(t,e,a){t.exports=a.p+"assets/img/go-map.5e7a6438.png"},612:function(t,e,a){"use strict";a.r(e);var v=a(17),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[t._v("#")]),t._v(" 结构")]),t._v(" "),v("p",[v("img",{attrs:{src:a(593),alt:"hero"}})]),t._v(" "),v("ol",[v("li",[v("p",[t._v("key 经过 hash 函数得到 64 位值，低 B 位用于选择桶，高 8 位用于加速查找 keys；")])]),t._v(" "),v("li",[v("p",[t._v("每个桶固定只有 8 对 k-v；")])]),t._v(" "),v("li",[v("p",[t._v("如果 key 和 value 均非指针类型且是内联的且 <= 128 字节（超过 128 字节会被转换为指针存储），go 会将 map 标记为不包含指针以避免 gc 扫描。但 bmap.overflow 是指针，为了避免溢出桶被回收，需要将所有溢出桶的地址都保存一份到 hmap.overflow 和 hmap.oldoverflow，这样 gc 扫描这两个字段即可。")])])]),t._v(" "),v("h2",{attrs:{id:"扩容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[t._v("#")]),t._v(" 扩容")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("装载因子大于 6.5，触发"),v("strong",[t._v("增量扩容")]),t._v("，B+1 <= 解决      hash 冲突频繁导致性能下降的问题；")])]),t._v(" "),v("li",[v("p",[t._v("桶总数 < 2^15 时，溢出桶总数 >= 桶总数，或当溢出桶总数 >= 2^15 时，说明值之间比较稀疏（可能发生了大量的值删除），触发"),v("strong",[t._v("等量扩容")]),t._v("；")])]),t._v(" "),v("li",[v("p",[t._v("两种扩容方式都会创建新的桶数组；")])]),t._v(" "),v("li",[v("p",[t._v("防止一次扩容需要搬迁的 key 的数量过多引发性能问题，扩容是渐进的。触发扩容的时机是新增元素，搬迁的时机则发生在新增、删除期间，每次最多搬迁 2 个bucket；")])]),t._v(" "),v("li",[v("p",[t._v("搬迁过程发生时，如何查找 key：先去旧的桶找，如果旧的桶已搬迁就在新的桶里找。")])])]),t._v(" "),v("h2",{attrs:{id:"注意点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[t._v("#")]),t._v(" 注意点")]),t._v(" "),v("ol",[v("li",[t._v("迭代 map 的结果是无序的：")]),t._v(" "),v("li",[t._v("为什么要设计成无序的：增量扩容时会发生 key 的搬迁，可能这个 key 会 rehash 到新的 bucket；")]),t._v(" "),v("li",[t._v("实现：选定一个随机的 bucket，再从其中选中一个随机的 cell 开始双重循环。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);