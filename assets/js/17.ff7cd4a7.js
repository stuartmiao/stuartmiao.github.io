(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{611:function(e,r,t){"use strict";t.r(r);var a=t(17),i=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"defer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[e._v("#")]),e._v(" defer")]),e._v(" "),t("ol",[t("li",[e._v("defer 会在当前函数 return 或 panic 前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源；")]),e._v(" "),t("li",[e._v("含 defer 表达式的函数返回过程：先给返回变量赋值，然后调用 defer 表达式，最后再是返回结果；")]),e._v(" "),t("li",[t("strong",[e._v("先进后出")]),e._v("：后调用的 defer 函数会先执行；")]),e._v(" "),t("li",[e._v("defer 语句的函数的参数会被预先计算，如果 defer 后面跟的是多级函数的调用，只有最后一个函数会被延迟执行。")])]),e._v(" "),t("h3",{attrs:{id:"练习题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#练习题"}},[e._v("#")]),e._v(" 练习题")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://go101.org/quizzes/defer-1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://go101.org/quizzes/defer-1.html"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://go101.org/quizzes/defer-2.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://go101.org/quizzes/defer-2.html"),t("OutboundLink")],1)])])]),e._v(" "),t("h2",{attrs:{id:"panic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#panic"}},[e._v("#")]),e._v(" panic")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 goroutine 中递归执行调用方的 defer；")])]),e._v(" "),t("li",[t("p",[e._v("panic 只会触发当前 goroutine 的 defer；")])]),e._v(" "),t("li",[t("p",[e._v("panic 允许在 defer 中嵌套多次调用，panic 是先进先出。")])])]),e._v(" "),t("h2",{attrs:{id:"recover"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#recover"}},[e._v("#")]),e._v(" recover")]),e._v(" "),t("ol",[t("li",[e._v("recover 可以中止 panic 造成的程序崩溃，使程序继续运行；")]),e._v(" "),t("li",[e._v("recover 在如下三种情况下返回 nil：")]),e._v(" "),t("li",[e._v("panic 参数为 nil；")]),e._v(" "),t("li",[e._v("goroutine 没有发生 panic；")]),e._v(" "),t("li",[e._v("recover 不是在 defer func 中调用。")]),e._v(" "),t("li",[t("strong",[e._v("一个 recover 调用只有在它的直接外层调用是一个延迟调用，并且此延迟调用的直接外层调用和当前协程中最新产生并且尚未恢复的 panic 相关联时才起作用")]),e._v("；一个有效的 recover 调用将最新产生并且尚未恢复的 panic 和与此 panic 相关联的函数调用剥离开来，并且返回当初传递给产生此 panic 的 panic 函数的参数；")]),e._v(" "),t("li",[e._v("在任一个时刻，一个函数调用最多只能和一个未恢复的 panic 相关联。 如果一个调用正和一个未恢复的 panic 相关联：\n"),t("ol",[t("li",[e._v("在此 panic 被 recover 之后，此调用将不再和任何 panic 相关联；")]),e._v(" "),t("li",[e._v("当在此函数调用中产生了一个新的 panic，此新 panic 将替换原来的未被恢复的 panic 作为和此函数调用相关联的 panic。")])])]),e._v(" "),t("li",[e._v("在某个时刻，一个协程中可能共存多个未被恢复的 panic，每个未被恢复的 panic 和此协程的调用堆栈中的一个尚未退出的函数调用相关联。当仍和一个未被恢复的 panic 相关联的一个内层函数调用退出完毕之后，此未被恢复的 panic 将"),t("strong",[e._v("传播")]),e._v("到调用此内层函数调用的外层函数调用中，这和在此外层函数调用中直接产生一个新的 panic 的效果是一样的。")])]),e._v(" "),t("h3",{attrs:{id:"练习题-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#练习题-2"}},[e._v("#")]),e._v(" 练习题")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://go101.org/quizzes/panic-recover-1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://go101.org/quizzes/panic-recover-1.html"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://go101.org/quizzes/panic-recover-2.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://go101.org/quizzes/panic-recover-2.html"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);r.default=i.exports}}]);