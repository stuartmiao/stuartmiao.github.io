(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{592:function(n,e,l){n.exports=l.p+"assets/img/channel.0a50537a.png"},610:function(n,e,l){"use strict";l.r(e);var t=l(17),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[n._v("#")]),n._v(" 结构")]),n._v(" "),t("p",[t("img",{attrs:{src:l(592),alt:"channel"}})]),n._v(" "),t("h2",{attrs:{id:"特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[n._v("#")]),n._v(" 特性")]),n._v(" "),t("ol",[t("li",[n._v("sync 包适用：\n"),t("ol",[t("li",[n._v("对性能要求极高的临界区；")]),n._v(" "),t("li",[n._v("保护某个结构内部状态和完整性。")])])]),n._v(" "),t("li",[n._v("channel 适用：\n"),t("ol",[t("li",[n._v("输出数据给其他使用方；")]),n._v(" "),t("li",[n._v("组合多个逻辑。")])])]),n._v(" "),t("li",[n._v("channel 的操作遵循 FIFO：\n"),t("ol",[t("li",[n._v("先从 channel 读取数据的 Goroutine 会先接收到数据；")]),n._v(" "),t("li",[n._v("先向 channel 发送数据的 Goroutine 会得到先发送数据的权利。")])])])]),n._v(" "),t("h2",{attrs:{id:"发送数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送数据"}},[n._v("#")]),n._v(" 发送数据")]),n._v(" "),t("ol",[t("li",[n._v("如果当前 channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；")]),n._v(" "),t("li",[n._v("如果 channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 sendx 所在的位置上；")]),n._v(" "),t("li",[n._v("如果不满足上面的两种情况，会创建一个 runtime.sudog 结构并将其加入 channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 channel 接收数据；")]),n._v(" "),t("li",[t("strong",[n._v("触发调度的时机")]),n._v("：\n"),t("ol",[t("li",[n._v("channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度；")]),n._v(" "),t("li",[n._v("发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权。")])])])]),n._v(" "),t("h2",{attrs:{id:"接收数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接收数据"}},[n._v("#")]),n._v(" 接收数据")]),n._v(" "),t("ol",[t("li",[n._v("如果 channel 为空，那么会直接调用 runtime.gopark 挂起当前 Goroutine；")]),n._v(" "),t("li",[n._v("如果 channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 会直接返回；")]),n._v(" "),t("li",[n._v("如果 channel 的 sendq 队列中存在挂起的 Goroutine，会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；")]),n._v(" "),t("li",[n._v("如果 channel 的缓冲区中包含数据，那么直接读取 recvx 索引对应的数据；")]),n._v(" "),t("li",[n._v("在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；")]),n._v(" "),t("li",[t("strong",[n._v("触发调度的时机")]),n._v("：\n"),t("ol",[t("li",[n._v("channel 为空；")]),n._v(" "),t("li",[n._v("缓冲区中不存在数据且不存在数据的发送者；")]),n._v(" "),t("li",[n._v("关闭管道会将 recvq 和 sendq 两个队列中的数据加入到 Goroutine 列表 gList 中，与此同时会清除所有 runtime.sudog 上未被处理的元素，在最后会为所有被阻塞的 Goroutine 调用 runtime.goready 触发调度。")])])])]),n._v(" "),t("h2",{attrs:{id:"注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[n._v("#")]),n._v(" 注意点")]),n._v(" "),t("ol",[t("li",[n._v("往被关闭的 channel 发送数据会触发 panic；")]),n._v(" "),t("li",[n._v("从被关闭的 channel 接收数据，会先读完channel里的数据。如果数据读完了，继续从 channel 读数据会拿到 channel 里存储的元素类型的零值；")]),n._v(" "),t("li",[n._v("关闭已被关闭的 channel 会触发 panic；")]),n._v(" "),t("li",[n._v("不要在消费端关闭 channel；")]),n._v(" "),t("li",[n._v("不要在有多个并行的生产者时对 channel 执行关闭操作。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);